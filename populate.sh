#!/usr/bin/env bash
# =============================================================================
# populate.sh — Bridge between audit snapshot and Ansible playbook
#
# Reads from ./snapshot/ and:
#   1. Generates group_vars/all.yml with real values
#   2. Copies config files into the appropriate roles/*/files/ directories
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SNAPSHOT_DIR="$SCRIPT_DIR/snapshot"
GROUP_VARS="$SCRIPT_DIR/group_vars/all.yml"
ROLES_DIR="$SCRIPT_DIR/roles"

# -- Colors & logging --------------------------------------------------------

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

info()    { echo -e "  ${BLUE}▸${NC} $*"; }
success() { echo -e "  ${GREEN}✓${NC} $*"; }
warn()    { echo -e "  ${YELLOW}⚠${NC} $*" >&2; }
error()   { echo -e "  ${RED}✗${NC} $*" >&2; }
section() { echo -e "\n${BOLD}${GREEN}━━━ $* ━━━${NC}"; }

# -- Helpers -----------------------------------------------------------------

# Read a file into a YAML list (one item per line)
yaml_list_from_file() {
    local file="$1"
    local indent="${2:-  }"
    if [[ -f "$file" ]] && [[ -s "$file" ]]; then
        while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" == \#* ]] && continue
            # Escape quotes in the value
            line="${line//\"/\\\"}"
            echo "${indent}- \"${line}\""
        done < "$file"
    fi
}

# Read JSON field from manifest
manifest_field() {
    local field="$1"
    python3 -c "import json; print(json.load(open('$SNAPSHOT_DIR/manifest.json')).get('$field', ''))" 2>/dev/null || echo ""
}

# Copy files from snapshot to role files/ dir (creating dir if needed)
copy_to_role() {
    local role="$1"
    local subdir="$2"   # subdirectory within role files/
    local source="$3"   # source path (file or dir)

    local dest="$ROLES_DIR/$role/files/$subdir"
    mkdir -p "$dest"

    if [[ -d "$source" ]]; then
        cp -r "$source"/* "$dest/" 2>/dev/null || true
    elif [[ -f "$source" ]]; then
        cp "$source" "$dest/" 2>/dev/null || true
    fi
}

# -- Validation --------------------------------------------------------------

if [[ ! -d "$SNAPSHOT_DIR" ]]; then
    error "Snapshot directory not found: $SNAPSHOT_DIR"
    error "Run audit.sh on the source machine first, then transfer snapshot/ here."
    exit 1
fi

if [[ ! -f "$SNAPSHOT_DIR/manifest.json" ]]; then
    error "manifest.json not found in snapshot directory."
    exit 1
fi

echo -e "${BOLD}Fedora Migration — Populate Playbook${NC}"
echo -e "Reading snapshot from: $SNAPSHOT_DIR"

# -- Read manifest -----------------------------------------------------------

section "Reading Manifest"
SOURCE_HOSTNAME="$(manifest_field hostname)"
SOURCE_USER="$(manifest_field username)"
SOURCE_FEDORA="$(manifest_field fedora_version)"
SOURCE_SHELL="$(manifest_field shell)"
info "Source: $SOURCE_HOSTNAME (Fedora $SOURCE_FEDORA, user: $SOURCE_USER)"

# =============================================================================
# Generate group_vars/all.yml
# =============================================================================

section "Generating group_vars/all.yml"

cat > "$GROUP_VARS" <<'HEADER'
---
# Fedora Migration Variables
# Auto-generated by populate.sh — review before running the playbook.
# Safe to commit (contains package names, not secrets).

HEADER

cat >> "$GROUP_VARS" <<EOF
# -- Source machine info ------------------------------------------------------
source_hostname: "$SOURCE_HOSTNAME"
source_fedora_version: "$SOURCE_FEDORA"

target_user: "{{ ansible_user_id }}"
target_home: "{{ ansible_env.HOME }}"

EOF

# -- Repos -------------------------------------------------------------------

section "Populating repos"

{
    echo "# -- Repos ----------------------------------------------------------------"

    # RPM Fusion
    local_rpmfusion_free=false
    local_rpmfusion_nonfree=false
    if [[ -f "$SNAPSHOT_DIR/packages/rpmfusion.txt" ]]; then
        grep -q "rpmfusion-free" "$SNAPSHOT_DIR/packages/rpmfusion.txt" && local_rpmfusion_free=true
        grep -q "rpmfusion-nonfree" "$SNAPSHOT_DIR/packages/rpmfusion.txt" && local_rpmfusion_nonfree=true
    fi
    echo "rpmfusion_free: $local_rpmfusion_free"
    echo "rpmfusion_nonfree: $local_rpmfusion_nonfree"
    [[ "$local_rpmfusion_free" == "true" ]] && success "RPM Fusion free" || true
    [[ "$local_rpmfusion_nonfree" == "true" ]] && success "RPM Fusion nonfree" || true

    # COPR repos
    echo ""
    echo "copr_repos:"
    if [[ -f "$SNAPSHOT_DIR/packages/copr-repos.txt" ]] && [[ -s "$SNAPSHOT_DIR/packages/copr-repos.txt" ]]; then
        yaml_list_from_file "$SNAPSHOT_DIR/packages/copr-repos.txt"
        success "$(wc -l < "$SNAPSHOT_DIR/packages/copr-repos.txt" | tr -d ' ') COPR repos"
    fi

    # Third-party repo files — copy to role and list them
    echo ""
    echo "third_party_repo_files:"
    if [[ -d "$SNAPSHOT_DIR/packages/dnf-repos" ]]; then
        mkdir -p "$ROLES_DIR/repos/files"
        for repo_file in "$SNAPSHOT_DIR/packages/dnf-repos"/*.repo; do
            [[ -f "$repo_file" ]] || continue
            local fname
            fname="$(basename "$repo_file")"
            # Skip fedora base repos and COPR repos (handled above)
            [[ "$fname" == fedora*.repo ]] && continue
            [[ "$fname" == _copr_* ]] && continue
            cp "$repo_file" "$ROLES_DIR/repos/files/"
            echo "  - \"$fname\""
        done
    fi
    echo ""
} >> "$GROUP_VARS"

# -- Packages ----------------------------------------------------------------

section "Populating packages"

{
    echo "# -- Packages -------------------------------------------------------------"
    echo "dnf_packages:"
    if [[ -f "$SNAPSHOT_DIR/packages/dnf-userinstalled.txt" ]]; then
        yaml_list_from_file "$SNAPSHOT_DIR/packages/dnf-userinstalled.txt"
        success "$(wc -l < "$SNAPSHOT_DIR/packages/dnf-userinstalled.txt" | tr -d ' ') DNF packages"
    fi

    # Flatpak remotes
    echo ""
    echo "flatpak_remotes:"
    if [[ -f "$SNAPSHOT_DIR/packages/flatpak-remotes.txt" ]] && [[ -s "$SNAPSHOT_DIR/packages/flatpak-remotes.txt" ]]; then
        while IFS=$'\t' read -r name url _options; do
            [[ -z "$name" || "$name" == "Name" ]] && continue
            echo "  - name: \"$name\""
            echo "    url: \"$url\""
        done < "$SNAPSHOT_DIR/packages/flatpak-remotes.txt"
    else
        echo "  - name: flathub"
        echo "    url: https://dl.flathub.org/repo/flathub.flatpakrepo"
    fi

    # Flatpak apps
    echo ""
    echo "flatpak_apps:"
    if [[ -f "$SNAPSHOT_DIR/packages/flatpak-apps.txt" ]] && [[ -s "$SNAPSHOT_DIR/packages/flatpak-apps.txt" ]]; then
        local flatpak_count=0
        while IFS=$'\t' read -r app_id origin _arch; do
            [[ -z "$app_id" || "$app_id" == "Application" ]] && continue
            echo "  - app_id: \"$app_id\""
            echo "    remote: \"${origin:-flathub}\""
            ((flatpak_count++))
        done < "$SNAPSHOT_DIR/packages/flatpak-apps.txt"
        success "$flatpak_count Flatpak apps"
    fi

    # Flatpak permission overrides
    echo ""
    echo "flatpak_overrides:"
    if [[ -d "$SNAPSHOT_DIR/packages/flatpak-overrides" ]]; then
        for f in "$SNAPSHOT_DIR/packages/flatpak-overrides"/*; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi

    # Snap packages
    echo ""
    echo "snap_packages:"
    if [[ -f "$SNAPSHOT_DIR/packages/snap-packages.txt" ]] && [[ -s "$SNAPSHOT_DIR/packages/snap-packages.txt" ]]; then
        while IFS= read -r line; do
            local snap_name
            snap_name="$(echo "$line" | awk '{print $1}')"
            [[ -z "$snap_name" ]] && continue
            echo "  - \"$snap_name\""
        done < "$SNAPSHOT_DIR/packages/snap-packages.txt"
        success "$(wc -l < "$SNAPSHOT_DIR/packages/snap-packages.txt" | tr -d ' ') Snap packages"
    fi

    # Removed default packages
    echo ""
    echo "dnf_packages_remove:"
    if [[ -f "$SNAPSHOT_DIR/packages/removed-defaults.txt" ]] && [[ -s "$SNAPSHOT_DIR/packages/removed-defaults.txt" ]]; then
        yaml_list_from_file "$SNAPSHOT_DIR/packages/removed-defaults.txt"
        success "$(wc -l < "$SNAPSHOT_DIR/packages/removed-defaults.txt" | tr -d ' ') default packages to remove"
    fi
    echo ""
} >> "$GROUP_VARS"

# -- Shell -------------------------------------------------------------------

# Copy Flatpak overrides to packages role
if [[ -d "$SNAPSHOT_DIR/packages/flatpak-overrides" ]]; then
    mkdir -p "$ROLES_DIR/packages/files/flatpak-overrides"
    cp "$SNAPSHOT_DIR/packages/flatpak-overrides"/* "$ROLES_DIR/packages/files/flatpak-overrides/" 2>/dev/null || true
fi

section "Populating shell"

{
    echo "# -- Shell ----------------------------------------------------------------"
    echo "default_shell: /bin/$SOURCE_SHELL"

    local pm="none"
    [[ -f "$SNAPSHOT_DIR/shell/plugin-manager.txt" ]] && pm="$(cat "$SNAPSHOT_DIR/shell/plugin-manager.txt" | tr -d '[:space:]')"
    echo "zsh_plugin_manager: \"$pm\""
    success "Plugin manager: $pm"

    # OMZ settings
    if [[ "$pm" == "oh-my-zsh" ]] && [[ -f "$SNAPSHOT_DIR/shell/omz-active.txt" ]]; then
        local omz_theme=""
        omz_theme="$(grep -oP 'ZSH_THEME="\K[^"]+' "$SNAPSHOT_DIR/shell/omz-active.txt" 2>/dev/null || echo "")"
        echo "omz_theme: \"$omz_theme\""

        local omz_plugins_raw=""
        omz_plugins_raw="$(grep -oP 'plugins=\(\K[^)]+' "$SNAPSHOT_DIR/shell/omz-active.txt" 2>/dev/null || echo "")"
        echo "omz_plugins:"
        if [[ -n "$omz_plugins_raw" ]]; then
            for p in $omz_plugins_raw; do
                echo "  - \"$p\""
            done
        fi
    else
        echo "omz_theme: \"\""
        echo "omz_plugins: []"
    fi
    echo ""
} >> "$GROUP_VARS"

# Copy shell files to role
info "Copying shell config files..."
mkdir -p "$ROLES_DIR/shell/files"
for f in "$SNAPSHOT_DIR/shell"/.z*; do
    [[ -f "$f" ]] && cp "$f" "$ROLES_DIR/shell/files/"
done
[[ -f "$SNAPSHOT_DIR/shell/starship.toml" ]] && cp "$SNAPSHOT_DIR/shell/starship.toml" "$ROLES_DIR/shell/files/"
[[ -d "$SNAPSHOT_DIR/shell/omz-custom" ]] && cp -r "$SNAPSHOT_DIR/shell/omz-custom" "$ROLES_DIR/shell/files/"
[[ -f "$SNAPSHOT_DIR/shell/.zsh_plugins.txt" ]] && cp "$SNAPSHOT_DIR/shell/.zsh_plugins.txt" "$ROLES_DIR/shell/files/"

# User scripts
for d in bin .local-bin; do
    if [[ -d "$SNAPSHOT_DIR/shell/user-scripts/$d" ]]; then
        mkdir -p "$ROLES_DIR/shell/files/user-scripts/$d"
        cp -r "$SNAPSHOT_DIR/shell/user-scripts/$d/"* "$ROLES_DIR/shell/files/user-scripts/$d/" 2>/dev/null || true
    fi
done

# Zsh custom dirs
for d in dot-zsh dot-zfunc dot-zsh.d; do
    [[ -d "$SNAPSHOT_DIR/shell/$d" ]] && cp -r "$SNAPSHOT_DIR/shell/$d" "$ROLES_DIR/shell/files/"
done
success "Shell files copied"

# -- Desktop -----------------------------------------------------------------

section "Populating desktop"

{
    echo "# -- Desktop --------------------------------------------------------------"
    # Cursor theme
    local cursor=""
    [[ -f "$SNAPSHOT_DIR/desktop/cursors/active-cursor-theme.txt" ]] && \
        cursor="$(cat "$SNAPSHOT_DIR/desktop/cursors/active-cursor-theme.txt" | tr -d '[:space:]')"
    echo "kde_cursor_theme: \"$cursor\""

    # Icon theme (from kdeglobals)
    local icon_theme=""
    if [[ -f "$SNAPSHOT_DIR/desktop/plasma-config/kdeglobals" ]]; then
        icon_theme="$(grep -oP 'Theme=\K.*' "$SNAPSHOT_DIR/desktop/plasma-config/kdeglobals" 2>/dev/null | head -1 || echo "")"
    fi
    echo "kde_icon_theme: \"$icon_theme\""
    echo ""
} >> "$GROUP_VARS"

# Copy desktop files to role
info "Copying desktop files..."
copy_to_role desktop plasma-config "$SNAPSHOT_DIR/desktop/plasma-config"
copy_to_role desktop wallpapers "$SNAPSHOT_DIR/desktop/wallpapers"
copy_to_role desktop color-schemes "$SNAPSHOT_DIR/desktop/color-schemes"
copy_to_role desktop aurorae "$SNAPSHOT_DIR/desktop/aurorae"
copy_to_role desktop icons "$SNAPSHOT_DIR/desktop/icons"
copy_to_role desktop fonts "$SNAPSHOT_DIR/desktop/fonts"
copy_to_role desktop konsole "$SNAPSHOT_DIR/desktop/konsole"
copy_to_role desktop sddm "$SNAPSHOT_DIR/desktop/sddm"
[[ -d "$SNAPSHOT_DIR/desktop/themes" ]] && copy_to_role desktop themes "$SNAPSHOT_DIR/desktop/themes"
[[ -d "$SNAPSHOT_DIR/desktop/kwin" ]] && copy_to_role desktop kwin "$SNAPSHOT_DIR/desktop/kwin"
[[ -d "$SNAPSHOT_DIR/desktop/knewstuff3" ]] && copy_to_role desktop knewstuff3 "$SNAPSHOT_DIR/desktop/knewstuff3"
[[ -d "$SNAPSHOT_DIR/desktop/kscreen" ]] && copy_to_role desktop kscreen "$SNAPSHOT_DIR/desktop/kscreen"
success "Desktop files copied"

# -- System ------------------------------------------------------------------

section "Populating system"

{
    echo "# -- System ---------------------------------------------------------------"

    # sysctl files
    echo "custom_sysctl_files:"
    if [[ -d "$SNAPSHOT_DIR/system/sysctl.d" ]]; then
        for f in "$SNAPSHOT_DIR/system/sysctl.d"/*.conf; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi

    # udev rules
    echo "custom_udev_rules:"
    if [[ -d "$SNAPSHOT_DIR/system/udev" ]]; then
        for f in "$SNAPSHOT_DIR/system/udev"/*.rules; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi

    # modprobe
    echo "custom_modprobe_files:"
    if [[ -d "$SNAPSHOT_DIR/system/modprobe.d" ]]; then
        for f in "$SNAPSHOT_DIR/system/modprobe.d"/*.conf; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi

    # fstab — extract non-default entries (skip root, boot, swap, tmpfs comments)
    echo "custom_fstab_entries:"
    if [[ -f "$SNAPSHOT_DIR/system/fstab" ]]; then
        while IFS= read -r line; do
            # Skip comments, empty lines, and standard mounts
            [[ -z "$line" || "$line" == \#* ]] && continue
            local mountpoint
            mountpoint="$(echo "$line" | awk '{print $2}')"
            # Skip standard system mounts
            case "$mountpoint" in
                /|/boot|/boot/efi|/home|swap|none) continue ;;
            esac
            echo "  - line: \"$line\""
        done < "$SNAPSHOT_DIR/system/fstab"
    fi

    # Custom /etc/hosts entries
    echo "custom_hosts_entries:"
    if [[ -f "$SNAPSHOT_DIR/system/hosts" ]]; then
        while IFS= read -r line; do
            [[ -z "$line" || "$line" == \#* ]] && continue
            # Skip standard localhost entries
            echo "$line" | grep -qE '^\s*(127\.0\.0\.1|::1)\s+(localhost|localhost\.localdomain)' && continue
            echo "  - \"$line\""
        done < "$SNAPSHOT_DIR/system/hosts"
    fi

    # Firewall — parse from captured config
    echo "firewall_services:"
    if [[ -f "$SNAPSHOT_DIR/system/firewall/firewall-list-all.txt" ]]; then
        local services_line
        services_line="$(grep 'services:' "$SNAPSHOT_DIR/system/firewall/firewall-list-all.txt" 2>/dev/null | sed 's/.*services: //')"
        for svc in $services_line; do
            echo "  - \"$svc\""
        done
    fi

    echo "firewall_ports:"
    if [[ -f "$SNAPSHOT_DIR/system/firewall/firewall-list-all.txt" ]]; then
        local ports_line
        ports_line="$(grep 'ports:' "$SNAPSHOT_DIR/system/firewall/firewall-list-all.txt" 2>/dev/null | sed 's/.*ports: //')"
        for port in $ports_line; do
            [[ -n "$port" ]] && echo "  - \"$port\""
        done
    fi

    # Enabled services (filter to non-default ones worth restoring)
    echo "enabled_services:"
    if [[ -f "$SNAPSHOT_DIR/system/systemd/system-enabled.txt" ]]; then
        yaml_list_from_file "$SNAPSHOT_DIR/system/systemd/system-enabled.txt"
    fi

    echo "disabled_services: []"
    echo "  # Review system-disabled.txt in snapshot and add services to disable here"

    echo "user_enabled_services:"
    if [[ -f "$SNAPSHOT_DIR/system/systemd/user-enabled.txt" ]]; then
        yaml_list_from_file "$SNAPSHOT_DIR/system/systemd/user-enabled.txt"
    fi

    echo "user_enabled_timers:"
    if [[ -f "$SNAPSHOT_DIR/system/systemd/user-timers.txt" ]]; then
        yaml_list_from_file "$SNAPSHOT_DIR/system/systemd/user-timers.txt"
    fi

    # GRUB command line
    local grub_cmdline=""
    if [[ -f "$SNAPSHOT_DIR/system/grub-defaults" ]]; then
        grub_cmdline="$(grep -oP 'GRUB_CMDLINE_LINUX_DEFAULT="\K[^"]+' "$SNAPSHOT_DIR/system/grub-defaults" 2>/dev/null || echo "")"
    fi
    echo "grub_cmdline_extra: \"$grub_cmdline\""

    # NetworkManager profiles
    echo "networkmanager_profiles:"
    if [[ -d "$SNAPSHOT_DIR/system/networkmanager" ]]; then
        for f in "$SNAPSHOT_DIR/system/networkmanager"/*; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi

    # CUPS printers
    local cups_found=false
    [[ -f "$SNAPSHOT_DIR/system/cups/printers.conf" ]] && cups_found=true
    echo "restore_cups_printers: $cups_found"

    # Crontab
    local has_crontab=false
    [[ -f "$SNAPSHOT_DIR/system/crontab.txt" ]] && [[ -s "$SNAPSHOT_DIR/system/crontab.txt" ]] && has_crontab=true
    echo "restore_crontab: $has_crontab"

    # logind.conf.d
    echo "custom_logind_confs:"
    if [[ -d "$SNAPSHOT_DIR/system/logind.conf.d" ]]; then
        for f in "$SNAPSHOT_DIR/system/logind.conf.d"/*.conf; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi
    local has_logind_conf=false
    [[ -f "$SNAPSHOT_DIR/system/logind.conf" ]] && has_logind_conf=true
    echo "restore_logind_conf: $has_logind_conf"

    # resolved.conf.d
    echo "custom_resolved_confs:"
    if [[ -d "$SNAPSHOT_DIR/system/resolved.conf.d" ]]; then
        for f in "$SNAPSHOT_DIR/system/resolved.conf.d"/*.conf; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi
    local has_resolved_conf=false
    [[ -f "$SNAPSHOT_DIR/system/resolved.conf" ]] && has_resolved_conf=true
    echo "restore_resolved_conf: $has_resolved_conf"

    # journald.conf.d
    echo "custom_journald_confs:"
    if [[ -d "$SNAPSHOT_DIR/system/journald.conf.d" ]]; then
        for f in "$SNAPSHOT_DIR/system/journald.conf.d"/*.conf; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi

    # sudoers.d
    echo "custom_sudoers_files:"
    if [[ -d "$SNAPSHOT_DIR/system/sudoers.d" ]]; then
        for f in "$SNAPSHOT_DIR/system/sudoers.d"/*; do
            [[ -f "$f" ]] || continue
            echo "  - \"$(basename "$f")\""
        done
    fi
    echo ""
} >> "$GROUP_VARS"

# Copy system files to role
info "Copying system files..."
copy_to_role system sysctl.d "$SNAPSHOT_DIR/system/sysctl.d"
copy_to_role system udev "$SNAPSHOT_DIR/system/udev"
copy_to_role system modprobe.d "$SNAPSHOT_DIR/system/modprobe.d"
copy_to_role system networkmanager "$SNAPSHOT_DIR/system/networkmanager"
[[ -f "$SNAPSHOT_DIR/system/dnf.conf" ]] && cp "$SNAPSHOT_DIR/system/dnf.conf" "$ROLES_DIR/system/files/"
[[ -f "$SNAPSHOT_DIR/system/environment" ]] && cp "$SNAPSHOT_DIR/system/environment" "$ROLES_DIR/system/files/"
copy_to_role system cups "$SNAPSHOT_DIR/system/cups"

# Custom systemd units
if [[ -d "$SNAPSHOT_DIR/system/systemd/custom-units" ]]; then
    mkdir -p "$ROLES_DIR/system/files/systemd-user-units"
    cp "$SNAPSHOT_DIR/system/systemd/custom-units"/* "$ROLES_DIR/system/files/systemd-user-units/" 2>/dev/null || true
fi

# Crontab
[[ -f "$SNAPSHOT_DIR/system/crontab.txt" ]] && cp "$SNAPSHOT_DIR/system/crontab.txt" "$ROLES_DIR/system/files/"

# logind.conf
[[ -f "$SNAPSHOT_DIR/system/logind.conf" ]] && cp "$SNAPSHOT_DIR/system/logind.conf" "$ROLES_DIR/system/files/"
copy_to_role system logind.conf.d "$SNAPSHOT_DIR/system/logind.conf.d"

# resolved.conf
[[ -f "$SNAPSHOT_DIR/system/resolved.conf" ]] && cp "$SNAPSHOT_DIR/system/resolved.conf" "$ROLES_DIR/system/files/"
copy_to_role system resolved.conf.d "$SNAPSHOT_DIR/system/resolved.conf.d"

# journald.conf.d
copy_to_role system journald.conf.d "$SNAPSHOT_DIR/system/journald.conf.d"

# sudoers.d
copy_to_role system sudoers.d "$SNAPSHOT_DIR/system/sudoers.d"

success "System files copied"

# -- Dev tools ---------------------------------------------------------------

section "Populating devtools"

{
    echo "# -- Dev tools ------------------------------------------------------------"

    echo "pip_user_packages:"
    [[ -f "$SNAPSHOT_DIR/devtools/pip-user.txt" ]] && yaml_list_from_file "$SNAPSHOT_DIR/devtools/pip-user.txt"

    echo "pipx_packages:"
    if [[ -f "$SNAPSHOT_DIR/devtools/pipx.txt" ]]; then
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            # pipx list --short outputs "package version"
            local pkg_name
            pkg_name="$(echo "$line" | awk '{print $1}')"
            echo "  - \"$pkg_name\""
        done < "$SNAPSHOT_DIR/devtools/pipx.txt"
    fi

    echo "npm_global_packages:"
    [[ -f "$SNAPSHOT_DIR/devtools/npm-globals.txt" ]] && yaml_list_from_file "$SNAPSHOT_DIR/devtools/npm-globals.txt"

    echo "cargo_packages:"
    [[ -f "$SNAPSHOT_DIR/devtools/cargo-crates.txt" ]] && yaml_list_from_file "$SNAPSHOT_DIR/devtools/cargo-crates.txt"

    echo "go_packages: []"
    echo "  # Go binary source paths not easily recoverable — review go-binaries.txt"

    echo "rustup_toolchains:"
    if [[ -f "$SNAPSHOT_DIR/devtools/rustup-toolchains.txt" ]]; then
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            # Extract toolchain name (before any " (..." suffix)
            local tc
            tc="$(echo "$line" | sed 's/ (.*//')"
            echo "  - \"$tc\""
        done < "$SNAPSHOT_DIR/devtools/rustup-toolchains.txt"
    fi

    echo "version_managers:"
    [[ -f "$SNAPSHOT_DIR/devtools/version-managers.txt" ]] && yaml_list_from_file "$SNAPSHOT_DIR/devtools/version-managers.txt"

    # VS Code / Codium extensions
    for vsc_cmd in code code-oss codium; do
        local varname="${vsc_cmd//-/_}_extensions"
        echo "${varname}:"
        if [[ -f "$SNAPSHOT_DIR/devtools/${vsc_cmd}-extensions.txt" ]] && [[ -s "$SNAPSHOT_DIR/devtools/${vsc_cmd}-extensions.txt" ]]; then
            yaml_list_from_file "$SNAPSHOT_DIR/devtools/${vsc_cmd}-extensions.txt"
            success "$(wc -l < "$SNAPSHOT_DIR/devtools/${vsc_cmd}-extensions.txt" | tr -d ' ') $vsc_cmd extensions"
        fi
    done

    # Container images (informational — for manual re-pull)
    echo "docker_images:"
    [[ -f "$SNAPSHOT_DIR/devtools/docker-images.txt" ]] && yaml_list_from_file "$SNAPSHOT_DIR/devtools/docker-images.txt"
    echo "podman_images:"
    [[ -f "$SNAPSHOT_DIR/devtools/podman-images.txt" ]] && yaml_list_from_file "$SNAPSHOT_DIR/devtools/podman-images.txt"
    echo ""
} >> "$GROUP_VARS"

# -- Audio -------------------------------------------------------------------

section "Populating audio"

{
    echo "# -- Audio ----------------------------------------------------------------"

    # Check for realtime scheduling config
    local rt_scheduling=false
    if ls "$SNAPSHOT_DIR/audio/"*realtime* &>/dev/null 2>&1 || ls "$SNAPSHOT_DIR/audio/"*audio* &>/dev/null 2>&1; then
        rt_scheduling=true
    fi
    echo "realtime_scheduling: $rt_scheduling"

    # Audio groups
    echo "audio_groups:"
    if [[ -f "$SNAPSHOT_DIR/audio/user-groups.txt" ]]; then
        local groups_str
        groups_str="$(cat "$SNAPSHOT_DIR/audio/user-groups.txt")"
        for g in audio realtime jackuser pipewire; do
            echo "$groups_str" | grep -qw "$g" && echo "  - \"$g\""
        done
    fi
    echo ""
} >> "$GROUP_VARS"

# Copy audio files to role
info "Copying audio files..."
copy_to_role audio pipewire "$SNAPSHOT_DIR/audio/pipewire"
copy_to_role audio wireplumber "$SNAPSHOT_DIR/audio/wireplumber"
copy_to_role audio reaper "$SNAPSHOT_DIR/audio/reaper"
[[ -f "$SNAPSHOT_DIR/audio/.jackdrc" ]] && cp "$SNAPSHOT_DIR/audio/.jackdrc" "$ROLES_DIR/audio/files/"

# Realtime limits
mkdir -p "$ROLES_DIR/audio/files/limits.d"
for f in "$SNAPSHOT_DIR/audio/"*realtime* "$SNAPSHOT_DIR/audio/"*audio*; do
    [[ -f "$f" ]] && cp "$f" "$ROLES_DIR/audio/files/limits.d/" 2>/dev/null || true
done

# Audio udev rules
copy_to_role audio udev-audio "$SNAPSHOT_DIR/audio/udev-audio"
success "Audio files copied"

# -- Third-party -------------------------------------------------------------

section "Populating third-party"

{
    echo "# -- Third-party ----------------------------------------------------------"
    echo "thirdparty_manual:"

    # Items from /usr/local/bin
    if [[ -f "$SNAPSHOT_DIR/thirdparty/usr-local-bin/listing.txt" ]]; then
        while IFS=$'\t' read -r name ftype; do
            [[ -z "$name" ]] && continue
            echo "  - name: \"$name\""
            echo "    description: \"Found in /usr/local/bin ($ftype)\""
            echo "    source: \"unknown — check if available as RPM, Flatpak, or direct download\""
        done < "$SNAPSHOT_DIR/thirdparty/usr-local-bin/listing.txt"
    fi

    # Items from ~/.local/bin
    if [[ -f "$SNAPSHOT_DIR/thirdparty/user-local-bin/listing.txt" ]]; then
        while IFS=$'\t' read -r name ftype; do
            [[ -z "$name" ]] && continue
            echo "  - name: \"$name\""
            echo "    description: \"Found in ~/.local/bin ($ftype)\""
            echo "    source: \"unknown — check if available as RPM, Flatpak, or direct download\""
        done < "$SNAPSHOT_DIR/thirdparty/user-local-bin/listing.txt"
    fi

    # Items from /opt
    if [[ -f "$SNAPSHOT_DIR/thirdparty/opt/details.txt" ]]; then
        while IFS=$'\t' read -r name size; do
            [[ -z "$name" ]] && continue
            echo "  - name: \"$name\""
            echo "    description: \"Found in /opt ($size)\""
            echo "    source: \"unknown — check vendor website\""
        done < "$SNAPSHOT_DIR/thirdparty/opt/details.txt"
    fi

    # Items from ~/opt
    if [[ -f "$SNAPSHOT_DIR/thirdparty/user-opt/details.txt" ]]; then
        while IFS=$'\t' read -r name size; do
            [[ -z "$name" ]] && continue
            echo "  - name: \"$name\""
            echo "    description: \"Found in ~/opt ($size)\""
            echo "    source: \"unknown — check vendor website\""
        done < "$SNAPSHOT_DIR/thirdparty/user-opt/details.txt"
    fi

    # AppImages
    if [[ -f "$SNAPSHOT_DIR/thirdparty/appimages.txt" ]] && [[ -s "$SNAPSHOT_DIR/thirdparty/appimages.txt" ]]; then
        while IFS= read -r appimage_path; do
            [[ -z "$appimage_path" ]] && continue
            local ai_name
            ai_name="$(basename "$appimage_path" .AppImage)"
            echo "  - name: \"$ai_name\""
            echo "    description: \"AppImage at $appimage_path\""
            echo "    source: \"Re-download from original source\""
        done < "$SNAPSHOT_DIR/thirdparty/appimages.txt"
    fi
    echo ""
} >> "$GROUP_VARS"

# Copy desktop files
copy_to_role thirdparty desktop-files "$SNAPSHOT_DIR/thirdparty/desktop-files"

# Copy user-level third-party directories (can be restored directly)
if [[ -d "$SNAPSHOT_DIR/thirdparty/user-opt" ]]; then
    copy_to_role thirdparty user-opt "$SNAPSHOT_DIR/thirdparty/user-opt"
    # Remove audit metadata — only actual program dirs should be deployed
    rm -f "$ROLES_DIR/thirdparty/files/user-opt/listing.txt" \
          "$ROLES_DIR/thirdparty/files/user-opt/details.txt"
fi
if [[ -d "$SNAPSHOT_DIR/thirdparty/user-local-bin" ]]; then
    copy_to_role thirdparty user-local-bin "$SNAPSHOT_DIR/thirdparty/user-local-bin"
    rm -f "$ROLES_DIR/thirdparty/files/user-local-bin/listing.txt"
fi
success "Third-party items catalogued"

# -- Hardware ----------------------------------------------------------------

section "Populating hardware"

{
    echo "# -- Hardware -------------------------------------------------------------"

    # Detect target CPU vendor (use what's on this machine, not the source)
    local cpu_vendor="unknown"
    if grep -qi "intel" /proc/cpuinfo 2>/dev/null; then
        cpu_vendor="intel"
    elif grep -qi "amd" /proc/cpuinfo 2>/dev/null; then
        cpu_vendor="amd"
    fi

    echo "install_intel_microcode: $([ "$cpu_vendor" = "intel" ] && echo true || echo false)"
    echo "install_amd_microcode: $([ "$cpu_vendor" = "amd" ] && echo true || echo false)"

    # TLP
    local tlp=false
    [[ -f "$SNAPSHOT_DIR/hardware/tlp.conf" ]] && tlp=true
    echo "tlp_enabled: $tlp"
    echo "power_profiles_daemon: $([ "$tlp" = "false" ] && echo true || echo false)"
    echo ""
} >> "$GROUP_VARS"

# Copy hardware files
[[ -f "$SNAPSHOT_DIR/hardware/tlp.conf" ]] && cp "$SNAPSHOT_DIR/hardware/tlp.conf" "$ROLES_DIR/hardware/files/"
if [[ -d "$SNAPSHOT_DIR/hardware/tlp.d" ]]; then
    mkdir -p "$ROLES_DIR/hardware/files/tlp.d"
    cp -r "$SNAPSHOT_DIR/hardware/tlp.d/"* "$ROLES_DIR/hardware/files/tlp.d/" 2>/dev/null || true
fi
success "Hardware config populated"

# -- Dotfiles (copy to respective locations) ---------------------------------

section "Populating dotfiles"

# The broad ~/.config/ capture goes to the desktop role as additional configs
# and specific items to their respective roles
if [[ -d "$SNAPSHOT_DIR/dotfiles/config" ]]; then
    # SSH config
    [[ -f "$SNAPSHOT_DIR/dotfiles/ssh-config" ]] && info "SSH config in snapshot (copy manually to ~/.ssh/config)"

    # Git config
    for f in .gitconfig .gitignore_global .editorconfig; do
        if [[ -f "$SNAPSHOT_DIR/dotfiles/$f" ]]; then
            mkdir -p "$ROLES_DIR/shell/files"
            cp "$SNAPSHOT_DIR/dotfiles/$f" "$ROLES_DIR/shell/files/"
            info "Copied $f to shell role"
        fi
    done
fi

# SSH authorized_keys
if [[ -f "$SNAPSHOT_DIR/dotfiles/ssh-authorized_keys" ]]; then
    mkdir -p "$ROLES_DIR/shell/files"
    cp "$SNAPSHOT_DIR/dotfiles/ssh-authorized_keys" "$ROLES_DIR/shell/files/"
    info "SSH authorized_keys copied to shell role"
fi

# GPG keyring
if [[ -d "$SNAPSHOT_DIR/dotfiles/gnupg" ]]; then
    mkdir -p "$ROLES_DIR/shell/files/gnupg"
    for f in pubring.asc ownertrust.txt gpg.conf gpg-agent.conf; do
        [[ -f "$SNAPSHOT_DIR/dotfiles/gnupg/$f" ]] && cp "$SNAPSHOT_DIR/dotfiles/gnupg/$f" "$ROLES_DIR/shell/files/gnupg/"
    done
    info "GPG public keyring copied to shell role"
fi

# MIME default applications
if [[ -f "$SNAPSHOT_DIR/dotfiles/mimeapps.list" ]]; then
    mkdir -p "$ROLES_DIR/desktop/files/plasma-config"
    cp "$SNAPSHOT_DIR/dotfiles/mimeapps.list" "$ROLES_DIR/desktop/files/plasma-config/"
    info "MIME default applications copied to desktop role"
fi

# XDG user directories
if [[ -f "$SNAPSHOT_DIR/dotfiles/user-dirs.dirs" ]]; then
    mkdir -p "$ROLES_DIR/desktop/files/plasma-config"
    cp "$SNAPSHOT_DIR/dotfiles/user-dirs.dirs" "$ROLES_DIR/desktop/files/plasma-config/"
    info "XDG user directories copied to desktop role"
fi

success "Dotfiles processed"

# =============================================================================
# Final summary
# =============================================================================

section "Population Complete"
echo ""
echo -e "  ${BOLD}Generated:${NC} $GROUP_VARS"
echo -e "  ${BOLD}Role files:${NC} populated in $ROLES_DIR/*/files/"
echo ""
echo -e "  ${BOLD}Next steps:${NC}"
echo -e "  1. Review $GROUP_VARS and adjust as needed"
echo -e "  2. Run: ${BOLD}ansible-playbook site.yml --check --diff${NC}  (dry run)"
echo -e "  3. Run: ${BOLD}ansible-playbook site.yml --ask-become-pass${NC}  (apply)"
echo ""
warn "Review group_vars/all.yml before committing — it may contain usernames and hostnames."
